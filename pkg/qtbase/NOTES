General organization: modules contain classes, which contain methods

Modules: A module (i.e. all of Qt) roughly corresponds to an R
namespace. A package is required to define a namespace, which would
make sense here. While this would be quite natural for user-defined
classes, the smoke-based modules are most easily provided dynamically.
We could try populating the namespace with the classes at build-time,
but it would be difficult. We would need to link to a shared object to
get the class names and then use exportPattern() in NAMESPACE. Then
there is the documentation, which is not yet build-time dynamic. Even
if it were, we would need to find the entire Qt documentation (for
conversion).  

Of course, at some point we would want documentation in R (and it
would be nice to avoid the use of Qt$ for retrieving every
class). Perhaps as a separate package?

To keep everything dynamic, we provide a special smoke module object
(e.g. "Qt") that supports '$' access. How is a such an object
represented in R? Extptr would be the obvious first choice, but the
symbol would need to be replaced or populated somehow at load
time. This is tricky, because all objects are duplicated upon
export. Could change the pointer address, or make it an environment,
instead. But what goes into the environment? A single external
pointer, or populate it with the class objects (directly or lazily)?
The most efficient would be to lazily accumulate the class
objects. Simplest would be to fully populate the environment and, if
done natively, this would be fast. Of course, the environment should
be locked after it is populated. The advantage over using an external
pointer is that everything is stored in a well-supported R object.

One interesting feature of an environment-based Smoke module is the
ability to attach() it, though this would not work in the package
context. Not that it would help much.

Class objects: extracted using $ from a module object. These should
extend 'function' so that they can be invoked as constructors.

Methods: These are the messages that can be received by a particular
class of object. Some are static (sent to the class), while others are
sent to specific instances. Methods must be keyed by signature, not
only by name, like classes. But the user will not want to specify the
signature; this should be automatically resolved from the method name
and argument types. The latter are not known until invocation, so the
method wrapper, retrieved by name, needs to perform the selection.

Given the functional nature of R, it may be natural to represent a
method as a function, where say the first argument represents the
class object or instance. This gives rise to familiar behavior, like:

> lapply(widgets, Qt$QWidget$show)

This leads quickly to questioning why the first argument is special,
and then one arrives at multiple dispatch systems like S4. Multiple
dispatch interferes with bundling, and thus conflicts with the design
of C++ and thus Qt. With single dispatch, it seems redundant to
specify the initial 'self' parameter, as the message has already been
delivered to a specific instance. The parameters then consitute the
message contents. Here is a compromise:

> lapply(widgets, qinvoke, "show")

This uses a function, qinvoke, to send the message of type "show" to
each widget in the list. This might be preferable to the former
approach, since calling '$' is more explicitly leveraging named state,
which is not a purely functional concept. Explicit 'self' can come in
handy, however, to implement a method with an existing ordinary
function. In this case, though, delegation is probably sufficient. In
short, we take Ruby over Python.

How then is the named state stored? The natural way is an
environment. We would prefer not to create a static environment for
every class, though. Rather, the environment for a class (or rather
two environments, to separate static and instance methods) should be
populated upon first retrieval of the class from the Smoke
module. This suggests that the module environment needs to be
dynamically bound, probably using ObjectTable, to avoid any overhead.

Instance methods: Use the $ syntax on the instance.
Static methods: Use $ syntax on a class object.

Global functions: Use $ syntax on a module object. Unlikely to be
useful, but could be stored with the class objects.

Signals:
Emitting a signal: just like an instance method
Connecting a signal handler: qconnect() or some fancy syntax?

Accessing properties: $ for getting and $<- for setting. Potential
for conflicts between property getting and method invocation. Could
try fancy call parsing for determining which is desired, but
simpler to favor properties. qinvoke() and qproperty() are always
available. Note properties are based on QVariant, not Smoke.

Instances: Need to store the pointer somewhere. Could just make this
an external pointer, but might be more useful as an environment, with
the pointer stored as an attribute. The environment would dynamically
bind closures for each method (and property if a QObject). It would
also contain the symbol 'self' which refers to the environment.

User Classes: We need a simple mechanism for defining new classes and
add methods to classes. Usually, these will be overrides of native
virtual methods. Example syntax:

> MyWindow <- qclass("MyWindow", Qt$QWindow)
> MyWindow$actionEvent <- function(event) { }
> MyWindow$mySlot <- qslot(function(x) { })
> MyWindow$myStaticMethod <- qstatic(function(x) { })

The 'MyWindow' object is a class object, like Qt$QWidget.

User Methods: Methods stored in a class-level environment, which is
referenced from each instance. The methods will be enclosed within the
instance environment. One question is disambiguation of overloaded
virtuals. In such cases, it may be necessary to do something like:

> MyWindow$overloadedMethod <- qmethod(function(x) { }, c("integer", "integer"))

In order to keep the method selection centralized in native code, a
wrapper also needs to be added, just like for native methods. The
method implementation is then called from native code. This might be
going too far though. R is a dynamically typed language, and a
function will accept any invocation, as long as the argument count is
not exceeded. If multiple dispatch is required, one can always
delegate to an S4 generic.

Another issue is chaining up to the parent class. Here is one syntax:

> Parent$foo()

Where 'Parent' is the name of a class from which this instance is
derived. This means the classes need to behave specially inside the
instance method.

User objects: Should support storing fields in an environment. Should
not need to declare these, unless they are properties. The instance
environment should inherit from this field environment.

----------------------------------------------------------
C++ Design
----------------------------------------------------------


Thoughts:
   An R user requests a method invocation, providing the method name,
   the target and the arguments. We need to:
   1) Find the method given the name, target class and argument types
   2) Marshal the arguments
   3) Invoke the method
   4) Marshal the return value
   5) Return the value to R

   We start with a MethodCallRequest, constructed by the R
   wrapper. Currently, we pass the MethodCallRequest to a
   MethodSelector to obtain the MethodCall, which is then evaluated to
   obtain the result for returning to R. The MethodCall consists of an
   Executor and the arguments. When evaluated, the MethodCall marshals
   the arguments by delegating to TypeHandlers and then passes itself
   to an Executor for method execution. The Executor is an adaptor
   that obtains the necessary information from the MethodCall to
   invoke the Method. Finally, it marshals the return value with a
   TypeHandler and returns the result to the wrappers. This could be
   simplified by having the Method play the role of the Executor and
   perform the low-level invocation based on the MethodCall.

   We could reduce the MethodCallRequest to a MethodRequest, with only
   type information, no data. This would then be passed to the
   MethodSelectors to obtain a Method. The Method would be passed the
   arguments, perhaps through overloading invoke() or passing a
   MarshalContext. The MarshalContext might be preferred, since it
   would avoid the need for each Method to have its own set of
   overloads. Either way, the Method obtains a MarshalContext to
   marshal the arguments, call itself, and marshal the return value,
   which the Method returns to the wrappers. This is strange, because
   the Method is presiding over the marshalling, as well as the
   low-level invocation. This could be avoided by creating a
   MethodCall from the Method and the arguments, and evaluating
   it. The Method would be the most natural factory of the MethodCall,
   but then it is playing too many roles. The question is whether the
   ability to select a method separate from invocation is worth the
   complexity. Given there is no use-case, probably not.

   Here is a variation on the first idea:
   1) MethodSelector transforms the MethodCallRequest to a MethodCall.
   2) When MethodCall is evaluated, it passes itself to its Method
   3) The Method requests the required stack from the Methodcall,
   either R or C++/Smoke.
   4) If the request is across the marshalling boundary, the arguments
   are marshalled, and the method is invoked again, this time with the
   arguments available. The original request comes back empty, and is
   ignored by the Method.
   5) The result is retrieved and returned to R by the wrappers.

   Wow, #4 is a bit complicated. Given that we only have two stacks (R
   and Smoke/C++), we can just ask the Method which it requires. The
   combination of the Method type and the stack provided to the
   MethodCall determines the marshal mode (Identity, RToSmoke, SmokeToR).
   
   This should easily handle R->R, R->Smoke, and R->Moc. Handling
   callbacks, e.g. Smoke->R and Moc->R, is more complicated. Idea:
   reverse the process. Start with a SmokeMethod or MocMethod that
   delegates to an RMethod. The Smoke/MocMethod creates a MethodCall
   to the RMethod and evaluates it. For SmokeMethod, it would probably
   be more direct to just create the MethodCall and eval it. MocMethod
   handles the bridging of the Moc and Smoke stacks.

   Taking that idea to the extreme, we have all invocations going
   through proxy methods. For example, the R invocation will call an
   RProxyMethod, which will create the MethodCallRequest, pass it to
   the MethodSelector to obtain a MethodCall, evaluate the call, and
   return the result in the appropriate manner. This seems elegant.

   Another question: should the MethodCallRequest and MethodCall be
   part of the same hierarchy, as they share many of the same
   attributes? As in, BoundMethodCall and UnboundMethodCall, both
   inheriting from MethodCall? The BoundMethodCall would gain a
   Method. It is also possible to make the Method optional on the
   MethodCall and add an isBound() method. This might work, but the
   Binder/Selector usually only understands one type of request
   (foreign or native). Is that true?  In theory, the MethodSelector only
   needs to know:
   1) Identity of instance, if object method (SmokeObject <-> SEXP)
   2) Class of method, if static method (string)
   3) Name of method (string)
   4) Types of arguments (vector of SmokeTypes)
   Note that the actual argument values are not on this list. They are
   only used now to build the MethodCall, but if we already *have* a
   MethodCall, this is not an issue.
   
   To get SmokeTypes for R objects, we will need an extensible
   mechanism that could probably replace the current scoring
   mechanism, i.e. all scoring is based on SmokeTypes, which is
   straight-forward.

   So should there be a separate (Un)BoundMethodCall type? The bound
   variant would add the eval() method. When binding, are we really
   making a new object, or just changing the state of the existing
   one? In some ways, this is identical to opening and closing a
   connection. We don't use different classes for that, so....
